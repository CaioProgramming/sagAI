uniform shader composable_shader;
uniform float2 iResolution;
// uniform float iTime; // Optional, if you want any time-based effects

// --- Target Color and Tolerances ---
uniform vec3 u_targetHighlightColorRGB; // The RGB color to highlight (normalized 0-1)
uniform float u_hueTolerance;          // e.g., 0.05 to 0.15 (5%-15% of the hue circle)
uniform float u_saturationThreshold;   // Min saturation original pixel must have (e.g., 0.1)
uniform float u_lightnessThreshold;    // Min lightness original pixel must have (e.g., 0.1)

// --- Highlight Modification ---
uniform float u_highlightSaturationBoost; // e.g., 1.5 to 3.0
uniform float u_highlightLightnessBoost;  // e.g., 0.1 to 0.3

// --- Non-Target Color Modification ---
uniform float u_desaturationFactorNonTarget; // 0.0 = B&W, 1.0 = original saturation

// --- Helper: RGB to HSL (Robust version recommended) ---
// (Source: https://www.chilliant.com/rgb2hsv.html adapted for HSL, or other standard implementations)
vec3 rgbToHsl(vec3 color) {
    float r = color.r;
    float g = color.g;
    float b = color.b;

    float maxVal = max(max(r, g), b);
    float minVal = min(min(r, g), b);
    float delta = maxVal - minVal;

    float h = 0.0;
    float s = 0.0;
    float l = (maxVal + minVal) / 2.0;

    if (delta > 0.00001) {
        s = (l < 0.5) ? (delta / (maxVal + minVal)) : (delta / (2.0 - maxVal - minVal));
        if (r == maxVal) {
            h = (g - b) / delta;
        } else if (g == maxVal) {
            h = 2.0 + (b - r) / delta;
        } else { // b == maxVal
            h = 4.0 + (r - g) / delta;
        }
        h /= 6.0;
        if (h < 0.0) h += 1.0;
    }
    return vec3(h, s, l);
}

// --- Helper: HSL to RGB (Robust version recommended) ---
float hueToRgbComponent(float p, float q, float t) {
    if (t < 0.0) t += 1.0;
    if (t > 1.0) t -= 1.0;
    if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
    if (t < 1.0/2.0) return q;
    if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
    return p;
}

vec3 hslToRgb(vec3 hsl) {
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;

    if (s == 0.0) {
        return vec3(l); // Achromatic
    } else {
        float q = (l < 0.5) ? (l * (1.0 + s)) : (l + s - l * s);
        float p = 2.0 * l - q;
        float r = hueToRgbComponent(p, q, h + 1.0/3.0);
        float g = hueToRgbComponent(p, q, h);
        float b = hueToRgbComponent(p, q, h - 1.0/3.0);
        return vec3(r, g, b);
    }
}

// Helper to calculate shortest distance between two hues (0-1 range)
float hueDistance(float hue1, float hue2) {
    float d = abs(hue1 - hue2);
    return min(d, 1.0 - d);
}


// --- Main Shader Logic ---
half4 main(float2 fragCoord) {
    half4 originalPixel = composable_shader.eval(fragCoord);
    vec3 colorRGB = originalPixel.rgb;

    // Convert target color and current pixel color to HSL
    vec3 targetHsl = rgbToHsl(u_targetHighlightColorRGB);
    vec3 currentHsl = rgbToHsl(colorRGB);

    bool isTargetColor = false;
    if (currentHsl.y >= u_saturationThreshold && currentHsl.z >= u_lightnessThreshold) {
        if (hueDistance(currentHsl.x, targetHsl.x) <= u_hueTolerance) {
            // Additional check: if target color is very desaturated (e.g. white/grey/black)
            // make hue tolerance less strict or rely more on lightness/saturation similarity.
            // For simplicity, this example primarily uses hue.
            // If targetHsl.y < 0.1 (very desaturated target), then matching becomes harder with hue alone.
            // One might compare lightness and saturation similarity more directly for grayscale targets.
            isTargetColor = true;
        }
    }


    if (isTargetColor) {
        // Boost the target color
        currentHsl.y = min(1.0, currentHsl.y * u_highlightSaturationBoost);
        currentHsl.z = clamp(currentHsl.z + u_highlightLightnessBoost, 0.0, 1.0);
        colorRGB = hslToRgb(currentHsl);
    } else {
        // Desaturate non-target colors
        // Simple grayscale: colorRGB = vec3(dot(colorRGB, vec3(0.299, 0.587, 0.114)));
        // Controlled desaturation:
        currentHsl.y *= u_desaturationFactorNonTarget;
        colorRGB = hslToRgb(currentHsl);

        // Optional: If you want non-highlighted areas to be truly B&W based on original luminance
        // float luminance = dot(originalPixel.rgb, vec3(0.2126, 0.7152, 0.0722));
        // colorRGB = vec3(luminance);
        // And then if you want to tint this B&W slightly (e.g. sepia), you could add another tint uniform.
        // For the example art, a clean B&W is good, so controlled desaturation (even to 0.0) is better.
    }

    return half4(clamp(colorRGB, 0.0, 1.0), originalPixel.a);
}